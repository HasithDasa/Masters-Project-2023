Algorithm finding_neighbors(small_bbox_list, edge_only_list):
    Initialize an empty list bbox_ones_mask_list
    Initialize an empty list intersected_comm_ones_list

    Iterate over small_bbox_list with index mask_index:
        Iterate over edge_only_list with index mask_index_checked:
            Iterate over edge_only_list[mask_index_checked] with index ones_index:
                If (small_bbox_list[mask_index][0] <= edge_only_list[mask_index_checked][ones_index][1] < small_bbox_list[mask_index][1]) and (small_bbox_list[mask_index][2] <= edge_only_list[mask_index_checked][ones_index][0] < small_bbox_list[mask_index][3]):
                    If mask_index != mask_index_checked:
                        Append [mask_index, mask_index_checked] to bbox_ones_mask_list
                        Append [(edge_only_list[mask_index_checked][ones_index][0], edge_only_list[mask_index_checked][ones_index][1]), mask_index, mask_index_checked] to intersected_comm_ones_list

    Return (bbox_ones_mask_list, intersected_comm_ones_list)


Algorithm finding_sections(large_bbox_list, edge_only_list):
    Initialize an empty list mask_inside_large_bbox_list

    Iterate over large_bbox_list with index lg_bb_ind and element lg_bb_ele:
        Iterate over edge_only_list with index mask_index_2 and element mask_ele_2:
            Initialize ones_count as 0

            Iterate over mask_ele_2:
                If (lg_bb_ele[0] <= co_with_ones_ele2[1] < lg_bb_ele[1]) and (lg_bb_ele[2] <= co_with_ones_ele2[0] < lg_bb_ele[3]):
                    Increment ones_count by 1

            If ones_count is equal to the length of mask_ele_2:
                Append [lg_bb_ind, mask_index_2] to mask_inside_large_bbox_list

    Return mask_inside_large_bbox_list


Algorithm results_function(small_bbox_list, large_bbox_list, edge_only_list):
    Create an executor using ThreadPoolExecutor

    # Submit the first for loop as a task
    task1 = executor.submit(finding_neighbors, small_bbox_list, edge_only_list)

    # Submit the second for loop as a task
    task2 = executor.submit(finding_sections, large_bbox_list, edge_only_list)

    # Wait for both tasks to complete
    results = [task1.result(), task2.result()]

    # Combine the results from both tasks and return them
    return results
